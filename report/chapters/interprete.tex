\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{Interprete}\label{c:interprete}
\section{Bytecode}\label{s:bytecode}
Il bytecode generato dal metodo \verb|codeGeneration| dei nodi dell'AST rispetta le regole della grammatica descritta nel file \verb|svm/lexer/SVM.g4|. Il linguaggio si ispira al set di istruzioni assembly x86. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{istruzioneCodiceGenerato}
    \caption{Schema istruzioni codice generato.}
    \label{fig:istruzione-codice-generato}
\end{figure}
Un'istruzioni \`e composta da diverse componenti, alcune obbligatorie, altre invece, opzionali:
\begin{itemize}
    \item \textbf{Istruzione}: stringa che permette di differenziare le diverse istruzioni. \`E l'unica componente obbligatoria in ogni istruzione e, nel caso di un'etichetta \`e utilizzata per dare il nome all'etichetta che si sta definendo;
    \item \textbf{Primo argomento}: stringa opzionale che permette in alcune istruzioni di specificare un registro o un numero;
    \item \textbf{Offset}: numero opzionale che permette di specificare quanto sommare al valore contenuto nel secondo argomento;
    \item \textbf{Secondo argomento}: stringa opzionale che permette in alcune istruzioni di specificare un registro o un numero;
    \item \textbf{Terzo argomento}: stringa opzionale che permette in alcune istruzioni di specificare un registro o un numero;
\end{itemize}
\section{CPU e memoria}\label{s:cpu-e-memoria}
L'interprete emula il comportamento di una CPU e di una memoria.
\subsection{CPU}
La CPU esegue le istruzioni passate al costruttore dell'interprete. Il metodo \verb|run| esegue un ciclo finch\'e o la memoria non termina o non ri raggiunge l'istruzione \verb|halt|. Ad ogni iterazione si accede all'istruzione indicata dal registro \verb|$ip| che viene poi incrementato di uno per l'iterazione sucessiva. Il comportamento da seguire dipende dall'istruzione, in particolare dal campo dati \verb|instruction|.

\subsection{Registri}
La cpu ha accesso a 8 registri:
\begin{itemize}
    \item \textbf{Instruction pointer} (\$ip): indica quale istruzione sar\`a la prossima ad essere eseguita;
    \item \textbf{Stack pointer} (\$sp): punta alla cima dello stack;
    \item \textbf{Heap pointer} (\$hp): punta alla prima posizione libera dello heap;
    \item \textbf{Frame pointer} (\$fp): punta all'access link corrente relatico al frame attivo;
    \item \textbf{Access link} (\$al): registro utilizzato per attraversare la catena statica degli scope;
    \item \textbf{Return address} (\$ra): registro utilizzato per salvare l'indirizzo (numero di istruzione) al quale ritornare una volta usciti da un frame;
    \item \textbf{Accumulatore} (\$a0): registro utilizzato per salvare il valore computato da alcune espressioni;
    \item \textbf{Registro general purpose} (\$t1): registro generico utilizzabile liberamento all'interno del codice generato.
\end{itemize}

\section{Record di attivazione}\label{s:record-di-attivazione}

\section{Funzionamento dell'interprete}\label{s:funzionamento-interprete}

\end{document}


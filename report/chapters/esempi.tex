\documentclass[../report.tex]{subfiles}
\begin{document}

\chapter{Esempi}\label{c:esempi}
Nelle seguenti sezioni sono riportati alcuni dei 27 esempi che sono stati utilizzati per accertarsi che il linguaggio \textbf{SimpLanPlus} rispettasse le specifiche richieste.
\section{Esempio 1}
\begin{lstlisting}
{
    /*
    This example shows the correct use of pointers in SimpLanPlus.
    The program is well formed and should output 1.
    */
    ^^int x;
    ^int y = new int;
    y^ = 1;
    x = new ^int;
    x^ = y;
    print x^^;
}
\end{lstlisting}
L'esempio presente nel file \verb|examples/example1.simplan| mostra il corretto uso dei puntatori. Vengono creati due puntatori, \verb|x| che punta ad un puntatore di interi e \verb|y| che punta a un intero. Le are di memoria puntate dai puntatori vengono scritte e, ne viene verificata l'avvenuta scrittura stampando il valore intero puntato dal puntatore puntato da \verb|x|.

\section{Esempio 2}
\begin{lstlisting}
{
    /*
    This example, among other things, shows what happens with the use of undeclared variables in SimpLanPlus.
    The program is not well formed and should display three errors:
      - "Missing declaration for ID: y."
      - "Variable x is used after deletion."
      - "Cannot perform effect analysis on y since it is not declared."
    In fact, x was deleted and yet used after its deletion; y was not even declared.
    */
    ^int x = new int;
    x^ = 1;
    delete x;
    y = x^; // this is wrong!
}
\end{lstlisting}
L'esempio presente nel file \verb|examples/example2.simplan| mostra il riconoscimento dell'utilizzo di un identificatore mai dichiarato. L'assegnazione del valore \verb|^x| alla variabile \verb|y| mai dichiarata viene riconosciuta come errore e correttamente riportata come tale dal messaggio \verb|Missing declaration for ID: y|. Inoltre, tramite l'analisi degli effetti, il compilatore riconosce che la variabile \verb|x| viene usata dopo essere stata cancellata mostrando all'utente il messaggio \verb|Variable x is used after deletion|.

\section{Esempio 3}
\begin{lstlisting}
{
    /*
    This example shows the importance of having a fix-point method implemented for performing the effects analysis on functions.
    The program is correct and should not output anything. Both a and b will be marked as deleted.
    */
    ^int a = new int;
    ^int b = new int;
    void h(^int x, ^int y) {
        if (y^ == 0)
            delete x;
        else {
            x^ = x^ - 1;
            h(y,x);
        }
    }
    a^ = 1;
    b^ = 0;
    h(a, b);
}
\end{lstlisting}
L'esempio presente nel file \verb|examples/example3.simplan| mostra il riconoscimento del problema dell'aliasing. La funzione \verb|void f(^int x, ^int y)| prende in input due puntatori e gli elimina. Quando la funzione viene invocata passandole lo stesso puntatore due volte \verb|f(x, x)| il compilatore riconosce, correttamente, che il puntatore \verb|x| verrebbe eliminato due volte e lo comunica all'utente tramite il messaggio \verb|Variable x is used after deletion|.

\section{Esempio 8}
\begin{lstlisting}
{
    /*
    This program shows the use of recursion.
    While calling function f in this way:
      f(5,4);
    is correct and terminates, calling:
      f(4,5);
    then the program should display:
      - "Reached max memory limit."
    */
    void f(int m, int n) {
        if (m>n) {
            print(m+n);
        }
        else {
            int x = 1;
            f(m+1,n+1);
        }
    }
    f(5,4);
}
\end{lstlisting}
L'esempio presente nel file \verb|examples/example4.simplan| mostra il corretto funzionamento di una chiamata ricorsiva. In caso si invertissero i parametri della chiamta, passando da \verb|f(5, 4)| a \verb|f(4, 5)|, questa funzione, correttamente, non potrebbe terminare. Essendo la memoria dell'interprete finita, prima o poi, verrebbe mostrato il messaggio di errore \verb|Reached max memory limit|.
\end{document}

